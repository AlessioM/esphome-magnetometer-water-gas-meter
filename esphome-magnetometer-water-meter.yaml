---
# This config uses the QMC5883L, a triple-axis magnetometer, to read your water mater or gas meter.

# Water meter

# The magnetometer is used to read the rotating magnet inside your water meter.
# Example photo that shows where to place the magnetometer sensor:
# https://community-assets.home-assistant.io/original/4X/3/0/e/30e9dc135ad01229ccb6ab3f3a326b3808377d66.jpeg

# This should be compatible will all the water meters the Flume water sensor is compatible with,
# which is compatible with about 95% of water meters in the United States.
# https://help.flumewater.com/en/articles/1618594-is-the-flume-device-compatible-with-all-water-meters

# Video showing the internals of a water meter: https://www.youtube.com/watch?v=M9nVkSZ6_H4

# See Figure 1: Nutating disc operation at https://www.instrumart.com/assets/RCDL-manual.pdf
# "The metering principle, known as positive displacement, is based on the continuous filling and discharging of the measuring
# chamber. Controlled clearances between the disc and the chamber provide precise measurement of each volume cycle.
# As the disc nutates, the center spindle rotates a magnet. The movement of the magnet is sensed through the meter wall
# by a follower magnet or by various sensors. Each revolution of the magnet is equivalent to a fixed volume of fluid, which is
# converted to any engineering unit of measure for totalization, indication or process control."

# Gas meter

# The magnetometer is used to read the diaphragm that expands and contracts inside your gas meter.
# Example photos that show where to place the magnetometer sensor:
# https://community-assets.home-assistant.io/original/4X/4/1/b/41bd209991e33482a2b946131adc066e558b7512.jpeg
# https://cdn.thingiverse.com/assets/ee/b0/23/c3/eb/large_display_f7052efe-7718-4e5d-9bbf-0088e2793f5c.jpg

# Video showing the internals of a gas meter: https://www.youtube.com/watch?v=WKlVmXe46w8

substitutions:
  # water or gas
  device_class: 'water'
  # mdi:water or mdi:meter-gas
  device_icon: 'mdi:water'
  # For water one of: CCF, ft³, gal, L, m³
  # For gas one of: CCF, ft³, m³
  volume_unit: 'gal'

  # If you need to change update_interval also change oversampling so that they match.
  # http://wiki.sunfounder.cc/images/7/72/QMC5883L-Datasheet-1.0.pdf
  # Oversampling | Output date rate | update_interval
  # ------------ |----------------- |----------------
  # 512x         | 10Hz             | >= 100ms
  # 256x         | 50Hz             | >= 20ms
  # 128x         | 100Hz            | >= 10ms
  # 64x          | 200Hz            | >= 5ms
  qmc5883l_update_interval: '10ms'
  qmc5883l_oversampling: '128x'

esphome:
  name: ${device_class}-meter
  friendly_name: ${device_class} meter

esp8266:
  board: d1_mini
  restore_from_flash: true

preferences:
  flash_write_interval: 60min

logger:
  logs:
    qmc5883l: INFO

api:
  encryption:
    key: !secret api_encryption_key
  services:
    # Based on https://esphome.io/components/sensor/pulse_meter.html#re-setting-the-total-pulse-count
    # Useful if you would like the total sensor to match what you see on your meter you are trying to match.
    - service: set_total
      variables:
        new_total: float
      then:
        - globals.set:
            id: half_rotations_total
            value: !lambda 'return new_total / id(volume_per_half_rotation).state;'

ota:
  password: !secret ota_password

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

globals:
  - id: half_rotations_total
    type: long
    restore_value: yes
    initial_value: '0'
  - id: half_rotations_flow
    type: long
    restore_value: no
    initial_value: '0'
  - id: axis_value_high
    type: bool
    restore_value: no
    initial_value: 'false'
  - id: calibrating
    type: bool
    restore_value: no
    initial_value: 'false'
  - id: calibrating_axis_x_min
    type: float
    restore_value: no
  - id: calibrating_axis_x_max
    type: float
    restore_value: no
  - id: calibrating_axis_y_min
    type: float
    restore_value: no
  - id: calibrating_axis_y_max
    type: float
    restore_value: no
  - id: calibrating_axis_z_min
    type: float
    restore_value: no
  - id: calibrating_axis_z_max
    type: float
    restore_value: no

number:
  # This depends on your specific water/gas meter model and its size.
  # To calibrate:
  # 1. Temporarily enable the "Half rotations total" sensor in HA.
  # 2. Write it down and also write down the reading on your water/gas meter.
  # 3. After a few hours or even days of regular water/gas usage, write down both of them again.
  # 4. Set this to the result of: diff of readings in volume_unit divided by diff of half rotations.
  # 5. Disable the "Half rotations total" sensor in HA.
  # Alternatively you can search for specifications of your specific water/gas meter and its size. e.g.
  # for Neptune T-10 from https://www.riotronics.com/wp-content/uploads/2019/11/NT10-4P-WaterRead-pdf3.01.pdf
  # Meter size | Pulses/Gallon
  # 5/8"       | 231.24
  # 3/4"       | 129.04
  # 1"         | 60.32
  # 1 1/2"     | 27.03
  # 2"         | 14.92
  # So for a 5/8" Neptune T-10 you will set this to 0.00864902 (2 / 231.24)
  # If you have the Flume water sensor you can use its lowest reported value. You can find it with:
  # select min(min) from statistics_short_term, statistics_meta where statistics_meta.statistic_id = 'sensor.water_usage_current' and statistics_meta.id = metadata_id and min > 0;
  # Defaulting to 0.01008156 which is for a 3/4" Badge Meter Model 35.
  - platform: template
    id: volume_per_half_rotation
    name: Volume per half rotation
    entity_category: config
    mode: box
    min_value: 0
    max_value: 9999999
    step: 0.000000001
    initial_value: 0.01008156
    restore_value: true
    optimistic: true
    unit_of_measurement: ${volume_unit}

  # To calibrate these just press the "Calibrate axis" button. Alternatively:
  # 1. Temporarily enable the Magnetic Field Strength X, Y, and Z sensors in HA.
  # 2. Run a light stream of water/gas.
  # 3. Observe which axis changes the most and its range.
  # 4. Set the axis and thresholds below. e.g. if y axis ranges from min to max use:
  #    Axis = y
  #    Threshold lower = min + 0.25 * (max - min)
  #    Threshold upper = max - 0.25 * (max - min)
  # 5. Disable the Magnetic Field Strength X, Y, and Z sensors in HA. Otherwise HA recorder will get overwhelmed.
  - platform: template
    id: threshold_lower
    name: Threshold lower
    entity_category: config
    mode: box
    min_value: -9999
    max_value: 9999
    step: 1
    initial_value: -9999
    restore_value: true
    optimistic: true
    unit_of_measurement: µT

  - platform: template
    id: threshold_upper
    name: Threshold upper
    entity_category: config
    mode: box
    min_value: -9999
    max_value: 9999
    step: 1
    initial_value: 9999
    restore_value: true
    optimistic: true
    unit_of_measurement: µT

  - platform: template
    id: calibration_seconds
    name: Calibration time
    entity_category: config
    icon: mdi:timer
    mode: box
    min_value: 1
    max_value: 999
    step: 1
    initial_value: 5
    restore_value: true
    optimistic: true
    unit_of_measurement: s

select:
  - platform: template
    id: axis
    name: "Axis"
    entity_category: config
    options:
      - x
      - y
      - z
      - None
    initial_option: None
    restore_value: true
    optimistic: true

button:
  - platform: template
    name: "Calibrate axis"
    entity_category: config
    on_press:
      - lambda: |-
          ESP_LOGI("calibration", "Starting calibration. Make sure ${device_class} is running");
          id(calibrating_axis_x_min) = std::numeric_limits<float>::max();
          id(calibrating_axis_x_max) = std::numeric_limits<float>::min();
          id(calibrating_axis_y_min) = std::numeric_limits<float>::max();
          id(calibrating_axis_y_max) = std::numeric_limits<float>::min();
          id(calibrating_axis_z_min) = std::numeric_limits<float>::max();
          id(calibrating_axis_z_max) = std::numeric_limits<float>::min();
          id(calibrating) = true;
      - delay: !lambda return id(calibration_seconds).state * 1000;
      - lambda: |-
          id(calibrating) = false;
          float x_range = id(calibrating_axis_x_max) - id(calibrating_axis_x_min);
          float y_range = id(calibrating_axis_y_max) - id(calibrating_axis_y_min);
          float z_range = id(calibrating_axis_z_max) - id(calibrating_axis_z_min);
          if (x_range < 0) {
            ESP_LOGW("calibration", "Didn't get any values for x");
          } else {
            ESP_LOGI("calibration", "x ranged from %.2f to %.2f",
                     id(calibrating_axis_x_min), id(calibrating_axis_x_max));
          }
          if (y_range < 0) {
            ESP_LOGW("calibration", "Didn't get any values for y");
          } else {
            ESP_LOGI("calibration", "y ranged from %.2f to %.2f",
                     id(calibrating_axis_y_min), id(calibrating_axis_y_max));
          }
          if (z_range < 0) {
            ESP_LOGW("calibration", "Didn't get any values for z");
          } else {
            ESP_LOGI("calibration", "z ranged from %.2f to %.2f",
                     id(calibrating_axis_z_min), id(calibrating_axis_z_max));
          }
          std::string axis_with_largest_range;
          float min, max;
          if (x_range > 10 && x_range > y_range && x_range > z_range) {
            axis_with_largest_range = "x";
            min = id(calibrating_axis_x_min);
            max = id(calibrating_axis_x_max);
          } else if (y_range > 10 && y_range > x_range && y_range > z_range) {
            axis_with_largest_range = "y";
            min = id(calibrating_axis_y_min);
            max = id(calibrating_axis_y_max);
          } else if (z_range > 10 && z_range > x_range && z_range > y_range) {
            axis_with_largest_range = "z";
            min = id(calibrating_axis_z_min);
            max = id(calibrating_axis_z_max);
          } else {
            ESP_LOGE("calibration", "Calibration failed. No axis had a range of at least 10");
            return;
          }
          float threshold_offset = 0.25 * (max - min);
          float lower_threshold = min + threshold_offset;
          float upper_threshold = max - threshold_offset;
          ESP_LOGI("calibration", "Selected %s axis with lower threshold: %.2f and upper threshold: %.2f",
                   axis_with_largest_range.c_str(), lower_threshold, upper_threshold);
          id(axis).publish_state(axis_with_largest_range);
          id(threshold_lower).publish_state(lower_threshold);
          id(threshold_upper).publish_state(upper_threshold);

interval:
  - interval: ${qmc5883l_update_interval}
    then:
      - lambda: |-
          if (id(calibrating)) {
            id(calibrating_axis_x_min) = min(id(calibrating_axis_x_min), id(qmc5883l_axis_x).state);
            id(calibrating_axis_x_max) = max(id(calibrating_axis_x_max), id(qmc5883l_axis_x).state);
            id(calibrating_axis_y_min) = min(id(calibrating_axis_y_min), id(qmc5883l_axis_y).state);
            id(calibrating_axis_y_max) = max(id(calibrating_axis_y_max), id(qmc5883l_axis_y).state);
            id(calibrating_axis_z_min) = min(id(calibrating_axis_z_min), id(qmc5883l_axis_z).state);
            id(calibrating_axis_z_max) = max(id(calibrating_axis_z_max), id(qmc5883l_axis_z).state);
          }

i2c:
  sda: SDA  # GPIO4 D2
  scl: SCL  # GPIO5 D1
  frequency: 50kHz

sensor:
  # Holds the magnetic field strength value of x, y, or z depending on the axis template select.
  # Increments counters when value crosses thresholds.
  - platform: template
    id: axis_value
    internal: true
    on_raw_value:
      then:
        - lambda: |-
            if (x > id(threshold_upper).state && !id(axis_value_high)) {
              id(axis_value_high) = true;
              id(half_rotations_total) += 1;
              id(half_rotations_flow) += 1;
              id(led).turn_on();
            } else if (x < id(threshold_lower).state && id(axis_value_high)) {
              id(axis_value_high) = false;
              id(led).turn_off();
            }

  # https://esphome.io/components/sensor/qmc5883l.html
  - platform: qmc5883l
    address: 0x0D
    field_strength_x:
      id: qmc5883l_axis_x
      name: Magnetic Field Strength X
      disabled_by_default: true
      entity_category: diagnostic
      on_raw_value:
        then:
          - lambda: if (id(axis).state == "x") id(axis_value).publish_state(x);
      filters:
        - delta: 3
    field_strength_y:
      id: qmc5883l_axis_y
      name: Magnetic Field Strength Y
      disabled_by_default: true
      entity_category: diagnostic
      on_raw_value:
        then:
          - lambda: if (id(axis).state == "y") id(axis_value).publish_state(x);
      filters:
        - delta: 3
    field_strength_z:
      id: qmc5883l_axis_z
      name: Magnetic Field Strength Z
      disabled_by_default: true
      entity_category: diagnostic
      on_raw_value:
        then:
          - lambda: if (id(axis).state == "z") id(axis_value).publish_state(x);
      filters:
        - delta: 3
    # Uncomment if your ESPHome release includes https://github.com/esphome/esphome/pull/6456
    # temperature:
    #   id: qmc5883l_temperature
    #   name: Temperature
    #   filters:
    #     - offset: 34.0
    #     - or:
    #       - throttle: 60s
    #       - delta: 0.5
    oversampling: ${qmc5883l_oversampling}
    update_interval: ${qmc5883l_update_interval}

  - platform: template
    id: sensor_half_rotations_total
    name: Half rotations total
    lambda: return id(half_rotations_total);
    update_interval: 1s
    disabled_by_default: true
    entity_category: diagnostic
    accuracy_decimals: 0
    state_class: 'total_increasing'
    icon: 'mdi:counter'
    filters:
      - delta: 1

  - platform: template
    id: sensor_total
    name: Total
    lambda: return id(half_rotations_total) * id(volume_per_half_rotation).state;
    update_interval: 10s
    accuracy_decimals: 2
    device_class: ${device_class}
    icon: ${device_icon}
    state_class: total_increasing
    unit_of_measurement: ${volume_unit}
    filters:
      - or:
        - throttle: 60s
        - delta: 0.01

  - platform: template
    id: sensor_flow
    name: Flow
    lambda: |-
      float flow = id(half_rotations_flow) * 6 * id(volume_per_half_rotation).state;
      id(half_rotations_flow) = 0;
      return flow;
    update_interval: 10s
    accuracy_decimals: 2
    state_class: measurement
    unit_of_measurement: ${volume_unit}/min
    filters:
      - or:
        - throttle: 60s
        - delta: 0.01

switch:
  # LED flashes faster/slower as magnet rotates on water meter
  - platform: gpio
    id: led
    pin:
      number: GPIO2
      inverted: true
